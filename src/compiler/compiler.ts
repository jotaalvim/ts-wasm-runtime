import {
  WASMCode,
  WASMFunction,
  WASMModule,
  WASMCodeParameter
} from "../wasm-vm/wasm-code"
import {
  ASTFunction,
  ASTFunctionInstruction,
  AnyParameter
} from "../wat-parser/func"
import { ASTModule } from "../wat-parser/module"
import { flatten } from "../misc/array"
import { ASTBlock, isBlockInstruction } from "../wat-parser/block"
import { NumberValue, ValType } from "../wat-parser/types"
import { Int32 } from "../number/Int32"
import { replaceIdentifiers } from "./precompile"

const compileInstruction = (
  inst: ASTFunctionInstruction<AnyParameter>
): WASMCode[] => {
  if (isBlockInstruction(inst)) {
    const block = inst as ASTBlock
    return compileBlock(block)
  }

  return [
    {
      opcode: inst.opType,
      parameters: inst.parameters as WASMCodeParameter[]
    }
  ]
}

const compileBlock = (block: ASTBlock): WASMCode[] => {
  const body = flatten(block.body.map(i => compileInstruction(i)))
  // block の場合はラベルが指す相対アドレスが末尾
  const labelPosition = block.opType === "block" ? body.length : 0
  const prologue = [
    { opcode: "_push", parameters: [block.results.length, labelPosition] }
  ]
  const epilogue = [{ opcode: "_pop", parameters: [] }]

  return [...prologue, ...body, ...epilogue]
}

const numberValue = (type: ValType, value: string): NumberValue => {
  switch (type) {
    case ValType.i32:
      return { [type]: value }
    case ValType.i64:
      return { [type]: value }
    case ValType.f32:
      return { [type]: value }
    case ValType.f64:
      return { [type]: value }
  }
}

const compileFunction = (ast: ASTFunction): WASMCode[] => {
  const prologue: WASMCode[] = flatten(
    // initialize local values
    ast.locals.map((l, i) => [
      {
        opcode: `${l.type}.const`,
        parameters: [numberValue(l.type, "0")]
      },
      { opcode: "set_local", parameters: [i + ast.parameters.length] }
    ])
  )

  const body = flatten(ast.body.map(i => compileInstruction(i)))

  const epilogue: WASMCode[] = [{ opcode: "_ret", parameters: [] }]

  return [...prologue, ...body, ...epilogue]
}

// Compiles AST generated by wat-parser.ts into machine code for wasm-vm.ts.
export const compile = (ast: ASTModule): WASMModule => {
  ast = replaceIdentifiers(ast)

  // TODO: functions 以外を実装
  const codes = ast.functions.map(fn => compileFunction(fn))

  const functions = ast.functions.map(fn => {
    let pointer = 0
    let i = 0
    for (const f of ast.functions) {
      if (f === fn) {
        break
      }
      pointer += codes[i].length
      i++
    }

    return {
      export: fn.export,
      identifier: fn.identifier,
      locals: fn.locals.map(l => l.type),
      parameters: fn.parameters.map(p => p.type),
      results: fn.results,
      pointer
    } as WASMFunction
  })

  const table: { [key: number]: number } = {}
  ast.elems.forEach(e => {
    const offset = Int32.obj(e.offset).toNumber()
    e.funcIds.forEach((id, i) => {
      table[offset + i] = id as number
    })
  })

  return {
    program: flatten(codes),
    functions,
    table
  }
}
