import { WASMCode, WASMFunctionTableEntry } from "../wasm-vm/wasm-code"
import { ASTFunction } from "../wasm-parser/func"
import { ASTModule } from "../wasm-parser/module"

const compileFunction = (ast: ASTFunction): WASMCode[] => {
  const fn: WASMCode[] = ast.body.map(inst => ({
    opcode: inst.opType,
    parameters: inst.parameters as number[] // TODO: 文字列を解決する
  }))
  if (fn[fn.length - 1].opcode !== "return") {
    fn.push({ opcode: "return", parameters: [] })
  }
  // TODO: 変数の identifier を index に置換
  return fn
}

const flatten = <T>(arr: T[][]): T[] => [].concat(...arr)

// Compiles AST generated by wasm-parser.ts into machine code for wasm-vm.ts.
export const compile = (
  ast: ASTModule
): [WASMCode[], WASMFunctionTableEntry[]] => {
  // TODO: functions 以外を実装
  const codes = ast.functions.map(compileFunction)

  const table = ast.functions.map(fn => {
    let pointer = 0
    let i = 0
    for (const f of ast.functions) {
      if (f === fn) {
        break
      }
      pointer += codes[i].length
      i++
    }

    return {
      export: fn.export,
      identifier: fn.identifier,
      locals: fn.locals,
      parameters: fn.parameters.map(p => p.type),
      pointer
    } as WASMFunctionTableEntry
  })

  // TODO: identifier を function table から pointer に置換

  return [flatten(codes), table]
}
