import { WASMCode, WASMFunctionTableEntry } from "../wasm-vm/wasm-code"
import { ASTFunction, ASTFunctionInstruction } from "../wasm-parser/func"
import { ASTModule } from "../wasm-parser/module"
import { flatten, uniq, fromPairs } from "../misc/array"
import { ASTBlock } from "../wasm-parser/block"
import { isString } from "util"

type IdentifierEntry = { [key: string]: number }

interface IdentifierTables {
  params: IdentifierEntry
  locals: IdentifierEntry
  labels: IdentifierEntry
  funcs: IdentifierEntry
}

const isIdentifier = (v: string | number): v is string => {
  return isString(v) && v.startsWith("$")
}

const compileInstruction = (
  inst: ASTFunctionInstruction,
  idTables: IdentifierTables
): WASMCode[] => {
  switch (inst.opType) {
    case "block": {
      const block = inst as ASTBlock
      return [{ opcode: "_push", parameters: [block.results.length] }]
    }
    case "end":
      return [{ opcode: "_pop", parameters: [] }]
    default:
      break
  }

  // 変数の identifier を index に置換
  // TODO: 文字列を解決する
  const parameters = inst.parameters.map(p => {
    if (isIdentifier(p)) {
      switch (inst.opType) {
        case "call":
          return idTables.funcs[p]
        case "br":
        case "br_if":
          return idTables.labels[p]
        default:
          return idTables.params[p]
      }
    }
    return p
  })

  return [
    {
      opcode: inst.opType,
      parameters
    }
  ]
}

const isBlock = (i: ASTFunctionInstruction): i is ASTBlock => {
  return i.opType === "block"
}

const createIdentifierTables = (ast: ASTFunction) => {
  const params = fromPairs(
    ast.parameters
      .map((p, i) => [p.identifier, i] as [string, number])
      .filter(e => e[0])
  )

  const locals = fromPairs(
    ast.locals
      .map((p, i) => [p.identifier, i] as [string, number])
      .filter(e => e[0])
  )

  const labels = fromPairs(
    ast.body
      .filter(isBlock)
      .map((b, i) => [b.identifier, i] as [string, number])
      .filter(e => e[0])
  )

  return {
    params,
    locals,
    labels
  }
}

const compileFunction = (
  ast: ASTFunction,
  funcs: IdentifierEntry
): WASMCode[] => {
  const idTables: IdentifierTables = { ...createIdentifierTables(ast), funcs }

  const prologue: WASMCode[] = flatten(
    // initialize local values
    ast.locals.map((l, i) => [
      { opcode: `${l.type}.const`, parameters: [0] },
      { opcode: "set_local", parameters: [i] }
    ])
  )

  const body = flatten(ast.body.map(i => compileInstruction(i, idTables)))

  const epilogue: WASMCode[] = [{ opcode: "_ret", parameters: [] }]

  return [...prologue, ...body, ...epilogue]
}

// Compiles AST generated by wasm-parser.ts into machine code for wasm-vm.ts.
export const compile = (
  ast: ASTModule
): [WASMCode[], WASMFunctionTableEntry[]] => {
  const functionIdTable: IdentifierEntry = fromPairs(
    ast.functions
      .map((fn, i) => [fn.identifier, i] as [string, number])
      .filter(e => e[0])
  )

  // TODO: functions 以外を実装
  const codes = ast.functions.map(fn => compileFunction(fn, functionIdTable))

  const table = ast.functions.map(fn => {
    let pointer = 0
    let i = 0
    for (const f of ast.functions) {
      if (f === fn) {
        break
      }
      pointer += codes[i].length
      i++
    }

    return {
      export: fn.export,
      identifier: fn.identifier,
      locals: fn.locals.map(l => l.type),
      parameters: fn.parameters.map(p => p.type),
      results: fn.results,
      pointer
    } as WASMFunctionTableEntry
  })

  // TODO: identifier を function table から pointer に置換

  return [flatten(codes), table]
}
