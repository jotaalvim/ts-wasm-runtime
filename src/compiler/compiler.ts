import { WASMCode, WASMFunctionTableEntry } from "../wasm-vm/wasm-code"
import { ASTFunction, ASTFunctionInstruction } from "../wat-parser/func"
import { ASTModule } from "../wat-parser/module"
import { flatten, fromPairs } from "../misc/array"
import { ASTBlock } from "../wat-parser/block"
import { isString } from "util"

type IdentifierEntry = { [key: string]: number }

interface IdentifierTables {
  locals: IdentifierEntry
  funcs: IdentifierEntry
}

const indexFromLast = <T>(arr: T[], pred: (item: T) => boolean): number => {
  for (let i = arr.length - 1; i >= 0; i--) {
    if (pred(arr[i])) {
      return arr.length - i - 1
    }
  }
  return -1
}

const isIdentifier = (v: string | number): v is string => {
  return isString(v) && v.startsWith("$")
}

const compileInstruction = (
  inst: ASTFunctionInstruction,
  idTables: IdentifierTables,
  labelStack: string[]
): WASMCode[] => {
  switch (inst.opType) {
    case "loop":
    case "block": {
      const block = inst as ASTBlock
      return compileBlock(block, idTables, labelStack)
    }
    default:
      break
  }

  // 変数の identifier を index に置換
  // TODO: 文字列を解決する
  const parameters = inst.parameters.map(p => {
    if (isIdentifier(p)) {
      switch (inst.opType) {
        case "call":
          return idTables.funcs[p]
        case "br":
        case "br_if": {
          return indexFromLast(labelStack, l => l === p)
        }
        default:
          return idTables.locals[p]
      }
    }
    return p
  })

  return [
    {
      opcode: inst.opType,
      parameters
    }
  ]
}

const compileBlock = (
  block: ASTBlock,
  idTables: IdentifierTables,
  labelStack: string[]
): WASMCode[] => {
  const labels = [...labelStack, block.identifier]

  const body = flatten(
    block.body.map(i => compileInstruction(i, idTables, labels))
  )
  // block の場合はラベルが指す相対アドレスが末尾
  const labelPosition = block.opType === "block" ? body.length : 0
  const prologue = [
    { opcode: "_push", parameters: [block.results.length, labelPosition] }
  ]
  const epilogue = [{ opcode: "_pop", parameters: [] }]

  return [...prologue, ...body, ...epilogue]
}

const createLocalTables = (ast: ASTFunction) => {
  const params = fromPairs(
    ast.parameters
      .map((p, i) => [p.identifier, i] as [string, number])
      .filter(e => e[0])
  )

  const locals = fromPairs(
    ast.locals
      .map(
        (p, i) => [p.identifier, ast.parameters.length + i] as [string, number]
      )
      .filter(e => e[0])
  )

  return { ...params, ...locals }
}

const compileFunction = (
  ast: ASTFunction,
  funcs: IdentifierEntry
): WASMCode[] => {
  const idTables: IdentifierTables = { locals: createLocalTables(ast), funcs }

  const prologue: WASMCode[] = flatten(
    // initialize local values
    ast.locals.map((l, i) => [
      { opcode: `${l.type}.const`, parameters: [0] },
      { opcode: "set_local", parameters: [i + ast.parameters.length] }
    ])
  )

  const body = flatten(ast.body.map(i => compileInstruction(i, idTables, [])))

  const epilogue: WASMCode[] = [{ opcode: "_ret", parameters: [] }]

  return [...prologue, ...body, ...epilogue]
}

// Compiles AST generated by wat-parser.ts into machine code for wasm-vm.ts.
export const compile = (
  ast: ASTModule
): [WASMCode[], WASMFunctionTableEntry[]] => {
  const functionIdTable: IdentifierEntry = fromPairs(
    ast.functions
      .map((fn, i) => [fn.identifier, i] as [string, number])
      .filter(e => e[0])
  )

  // TODO: functions 以外を実装
  const codes = ast.functions.map(fn => compileFunction(fn, functionIdTable))

  const table = ast.functions.map(fn => {
    let pointer = 0
    let i = 0
    for (const f of ast.functions) {
      if (f === fn) {
        break
      }
      pointer += codes[i].length
      i++
    }

    return {
      export: fn.export,
      identifier: fn.identifier,
      locals: fn.locals.map(l => l.type),
      parameters: fn.parameters.map(p => p.type),
      results: fn.results,
      pointer
    } as WASMFunctionTableEntry
  })

  return [flatten(codes), table]
}
