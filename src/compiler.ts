import { WASMCode, WASMContext } from "./wasm-code"
import { ASTModule, ASTFunction } from "./wasm-parser"

export interface WASMFunctionTableEntry {
  export: string
  identifier: string
  pointer: number
}

const compileFunction = (ast: ASTFunction): WASMCode[] => {
  const fn: WASMCode[] = ast.body.map(inst => ({
    opcode: inst.opType,
    value: inst.parameters
  }))
  if (fn[fn.length - 1].opcode !== "return") {
    fn.push({ opcode: "return" })
  }
  // TODO: 変数の identifier を index に置換
  return fn
}

const flatten = <T>(arr: T[][]): T[] => [].concat(...arr)

// Compiles AST generated by wasm-parser.ts into machine code for wasm-vm.ts.
export const compile = (
  ast: ASTModule
): [WASMCode[], WASMFunctionTableEntry[]] => {
  // TODO: functions 以外を実装
  const codes = ast.functions.map(compileFunction)

  const table = ast.functions.map(fn => {
    let pointer = 0
    let i = 0
    for (const f of ast.functions) {
      if (f === fn) {
        break
      }
      pointer += codes[i].length
      i++
    }

    return {
      export: fn.export,
      identifier: fn.identifier,
      pointer
    }
  })

  // TODO: identifier を function table から pointer に置換

  return [flatten(codes), table]
}
